# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Выбрал задачу на определение количества чисел, кратных 2, 3, 4, 5, 6, 7, 8 и 9 в диапазоне от 2 до 99

import sys

sum_1 = 0 # Считаем общую затраченную память для разных способов решения
sum_2 = 0
sum_3 = 0

def show(x): # Функция как в уроке.
    print(f'id ={id(x)}, type={type(x)}, size={sys.getsizeof(x)}, links={sys.getrefcount(x)}, obj={x}')
    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'): # Сработает, если на вход функции попадет словарь
            for key, value in x.items():
                show(key)
                show(value)
        else: # А это, если список (строчек моим кодом не предусмотрено)
            for i in range(len(x)):
                show(x[i])

"""Первый способ решения: через словарь"""

my_dict = {a: 0 for a in range(2, 10)} # {2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}

sum_1 += sys.getsizeof(my_dict) # Добавляем байты созданного словаря

print('Первый вариант — считаем память: словарь с пустыми значениями:')
show(my_dict)
print()

for i in range(2, 100): # Цикл, проверяющий каждое делимое

    if i % 2 == 0:
        my_dict[2] += 1
        if i % 4 == 0:
            my_dict[4] += 1
            if i % 8 == 0:
                my_dict[8] += 1

    if i % 3 == 0:
        my_dict[3] += 1
        if i % 6 == 0:
            my_dict[6] += 1
        if i % 9 == 0:
            my_dict[9] += 1

    if i % 5 == 0:
        my_dict[5] += 1

    if i % 7 == 0:
        my_dict[7] += 1

sum_1 += sys.getsizeof(i) # Добавляем к первой сумме байты, занятые переменной в цикле
sum_1 += sys.getsizeof(my_dict) # И обновленным словарем (не уверен, что так нужно было делать, но он изменился...)

print('Первый вариант — считаем память: переменная i:')
show(i)
print()
print('Первый вариант — считаем память: обновленный словарь')
show(my_dict)
print()
print('Ответ (первый способ решения):')
print(*my_dict.items())
print()

"""Второй способ решения задачи: цикл с подбором"""

my_list = [0, 0, 0, 0, 0, 0, 0, 0] # Пустой список
sum_2 += sys.getsizeof(my_list) # И добавление его памяти в переменную

print('Второй вариант — считаем память: пустой список')
show(my_list)
print()

for j in range(2, 100): # Цикл, который перебирает все делимые и делители, обновляя числа в пустом списке

    for k in range(2, 10):
        if j % k == 0:
            my_list[k - 2] += 1

print('Ответ (второй способ решения):')
print()

for l in range(len(my_list)): # Вывод ответа
    print(f'{l + 2} — {my_list[l]}')

sum_2 += sys.getsizeof(j) # Добавляем память переменных к сумме
sum_2 += sys.getsizeof(k)
sum_2 += sys.getsizeof(l)
sum_2 += sys.getsizeof(my_list) # И обновленного списка

print()
print('Второй вариант — считаем память: переменная j:')
show(j)
print()
print('Второй вариант — считаем память: переменная k:')
show(k)
print()
print('Второй вариант — считаем память: переменная l:')
show(l)
print()
print('Второй вариант — считаем память: обновленный список:')
show(my_list)
print()

"""Третий способ решения: куча переменных и цикл как в первом способе"""

div_2 = 0 #Создаем новую переменную-счетчик для каждого делимого
div_3 = 0
div_4 = 0
div_5 = 0
div_6 = 0
div_7 = 0
div_8 = 0
div_9 = 0

print('Третий вариант — считаем память новых переменных:')
show(div_2), show(div_3), show(div_4), show(div_5), show(div_6), show(div_7), show(div_8), show(div_9)
print()

sum_3 += sys.getsizeof(div_2) # Плюсуем память пока пустых переменных
sum_3 += sys.getsizeof(div_3)
sum_3 += sys.getsizeof(div_4)
sum_3 += sys.getsizeof(div_5)
sum_3 += sys.getsizeof(div_6)
sum_3 += sys.getsizeof(div_7)
sum_3 += sys.getsizeof(div_8)
sum_3 += sys.getsizeof(div_9)

for t in range(2, 100):

    if t % 2 == 0:
        div_2 += 1
        if t % 4 == 0:
            div_4 += 1
            if t % 8 == 0:
                div_8 += 1

    if t % 3 == 0:
        div_3 += 1
        if t % 6 == 0:
            div_6 += 1
        if t % 9 == 0:
            div_9 += 1

    if t % 5 == 0:
        div_5 += 1

    if t % 7 == 0:
        div_7 += 1

print('Третий вариант — считаем память: переменная t:')
show(t)
print()
print('Третий вариант — считаем память: обновленные переменные:')
show(div_2), show(div_3), show(div_4), show(div_5), show(div_6), show(div_7), show(div_8), show(div_9)
print()

sum_3 += sys.getsizeof(t) #Плюсуем память переменной из цикла

sum_3 += sys.getsizeof(div_2) # Плюсуем память обновленных переменных
sum_3 += sys.getsizeof(div_3)
sum_3 += sys.getsizeof(div_4)
sum_3 += sys.getsizeof(div_5)
sum_3 += sys.getsizeof(div_6)
sum_3 += sys.getsizeof(div_7)
sum_3 += sys.getsizeof(div_8)
sum_3 += sys.getsizeof(div_9)

print('Ответ (третий способ решения):')
print(f'2 — {div_2}, 3 — {div_3}, 4 — {div_4}, 5 — {div_5}, 6 — {div_6}, 7 — {div_7}, 8 — {div_8}, 9 — {div_9}')
print()

print(f'Память, затраченная первой программой — {sum_1} байт, второй — {sum_2}, третьей — {sum_3}.')

# Память, затраченная первой программой — 780 байт, второй — 356, третьей — 444.
# Выводы. Замер памяти говорит, что предпочтительнее всего второй вариант: с перебором всех чисел обоих диапазонов.
# Не уверен, что это верно, потому что мы считывали память переменных в циклах только по их завершении, а у остальных
# переменных замеряли память при каждом изменении. Тест показал больший объем памяти у первого варианта
# (он казался мне удобнее всего), нежели у третьего, учитывая, что в обоих способах использовался один и тот же цикл.
# В первом случае использовался словарь, а в третьем — куча переменных. Это связано с тем, что даже в одном словаре
# с разными ключами будет создано больше id, чем в куче переменных со значением 0 (там id будут одинаковые).
